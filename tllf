local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Player = Players.LocalPlayer
local Events = ReplicatedStorage:WaitForChild("Events")

local PickupEvent = Events:WaitForChild("Pickup")
local SetTool = Events:WaitForChild("SetTool")
local Consume = Events:WaitForChild("Consume")

local Vitals = Player:WaitForChild("PlayerData"):WaitForChild("Vitals")

local AUTO_FARM = true
local AUTO_PICKUP = true
local AUTO_MINE = true

local FARM_DELAY = 0.3
local PICKUP_DELAY = 0.25
local PICKUP_DISTANCE = 15
local AUTO_MINE_DELAY = 0.25

local HUNGER_OK = 50
local THIRST_OK = 50
local THIRST_SET = 85
local MAX_FOOD = 3
local MAX_WATER = 5

local ICE_NAME = "Floating Ice"
local ICE_CFRAME = CFrame.new(-1022, 12.5, -700)
local ICETP_CFRAME = CFrame.new(-1022, 16, -700)

local TOOLS = {
	Pick = "Serpentine Pick",
	Axe = "Serpentine Axe",
}

local AllowedItems = {
	Coin = true,
	Experience = true,
	Egg = true,
	Meat = true,
}

local handlingVitals = false

for _, v in ipairs(workspace:GetDescendants()) do
	if v:IsA("ProximityPrompt") then
		v.HoldDuration = 0
	end
end

task.spawn(function()
	while true do
		if AUTO_MINE and not handlingVitals then
			Events.Mine:FireServer()
		end
		task.wait(AUTO_MINE_DELAY)
	end
end)

local function getChar()
	return Player.Character
end

local function getHRP()
	local c = getChar()
	return c and c:FindFirstChild("HumanoidRootPart")
end

local function tp(cf)
	local hrp = getHRP()
	if hrp then
		hrp.CFrame = cf
	end
end

local function setTool(tool)
	SetTool:FireServer(tool)
	task.wait(0.15)
end

local function getItemPosition(item)
	if item:IsA("BasePart") then
		return item.Position
	end
	if item:IsA("Model") then
		local p = item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart", true)
		return p and p.Position
	end
end

local function isNear(item)
	local hrp = getHRP()
	if not hrp then return false end
	local pos = getItemPosition(item)
	if not pos then return false end
	return (hrp.Position - pos).Magnitude <= PICKUP_DISTANCE
end

task.spawn(function()
	while task.wait(PICKUP_DELAY) do
		if not AUTO_PICKUP then continue end
		local folder = workspace:FindFirstChild("Items")
		if not folder then continue end
		for _, item in ipairs(folder:GetChildren()) do
			if AllowedItems[item.Name] and isNear(item) then
				pcall(function()
					PickupEvent:FireServer(item)
				end)
			end
		end
	end
end)

local function handleThirst()
	if Vitals.Thirst.Value >= THIRST_OK then return end
	handlingVitals = true

	local ice = workspace.Decoration.Others:FindFirstChild(ICE_NAME)
	if ice then
		ice.Size = Vector3.new(1, 3, 3)
		ice.CFrame = ICE_CFRAME
	end

	tp(ICETP_CFRAME)

	local prompt = workspace.WaterPart and workspace.WaterPart:FindFirstChildOfClass("ProximityPrompt")
	if prompt then
		for i = 1, 4 do
			fireproximityprompt(prompt)
			task.wait(0.15)
		end
	end

	repeat
		Consume:FireServer("Water")
		task.wait(0.4)
	until Vitals.Thirst.Value >= THIRST_SET

	handlingVitals = false
end

local function findEggInWorld()
	local items = workspace:FindFirstChild("Items")
	if not items then return end
	for _, item in ipairs(items:GetChildren()) do
		if item.Name == "Egg" then
			return item
		end
	end
end

local function findChicken()
	for _, animal in ipairs(workspace.Animals:GetChildren()) do
		if animal.Name == "Chicken" and animal:FindFirstChild("HumanoidRootPart") then
			return animal
		end
	end
end

local function handleHunger()
	if Vitals.Hunger.Value >= HUNGER_OK then return end
	handlingVitals = true

	local egg = findEggInWorld()
	if egg then
		tp(CFrame.new(getItemPosition(egg)) + Vector3.new(0, 3, 0))
		handlingVitals = false
		return
	end

	local chicken = findChicken()
	if chicken then
		tp(chicken.HumanoidRootPart.CFrame * CFrame.new(0, 0, 3))
		repeat
			task.wait(0.5)
			egg = findEggInWorld()
		until egg or Vitals.Hunger.Value >= HUNGER_OK
		if egg then
			tp(CFrame.new(getItemPosition(egg)) + Vector3.new(0, 3, 0))
		end
	end
	
	for i = 1, MAX_FOOD do
		if Vitals.Hunger.Value >= HUNGER_OK then break end
		Consume:FireServer("Egg")
		task.wait(0.6)
	end

	handlingVitals = false
end

Vitals.Thirst.Changed:Connect(handleThirst)
Vitals.Hunger.Changed:Connect(handleHunger)

local function findNearestTree()
	local hrp = getHRP()
	if not hrp then return end
	local nearest, dist = nil, math.huge

	for _, tree in ipairs(workspace.Trees:GetChildren()) do
		local ref = tree:FindFirstChild("Reference")
		if ref then
			local d = (hrp.Position - ref.Position).Magnitude
			if d < dist then
				dist = d
				nearest = ref
			end
		end
	end

	return nearest
end

local function findRandomTree()
	local refs = {}
	for _, tree in ipairs(workspace.Trees:GetChildren()) do
		local ref = tree:FindFirstChild("Reference")
		if ref then
			table.insert(refs, ref)
		end
	end
	if #refs > 0 then
		return refs[math.random(1, #refs)]
	end
end

local function chopTree(ref)
	setTool(TOOLS.Axe)
	while ref and ref.Parent and not handlingVitals do
		tp(ref.CFrame + Vector3.new(0, 3, 0))
		task.wait(0.2)
	end
end

task.spawn(function()
	while task.wait(FARM_DELAY) do
		if not AUTO_FARM or handlingVitals then continue end

		local tree = findNearestTree()
		if not tree then
			tree = findRandomTree()
			if tree then
				tp(tree.CFrame + Vector3.new(0, 3, 0))
				task.wait(0.5)
			end
		end

		if tree then
			chopTree(tree)
		end
	end
end)

for _, v in pairs(getconnections(Player.Idled)) do
	v:Disable()
end
